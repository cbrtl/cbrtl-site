[{"content":"What is cbrtl? cbrtl is an attempt at creating a tight knit group of programmers to showcase and collaborate on projects and\nWhat do we do here? Create fun projects. Either in groups or in isolation. Organize community and online showcases for group and individual projects. Contribute to Open Source projects both in cbrtl and in other communities. Conduct code reviews and JAMs. Share resources to learn. Create and maintain dev-journals and blogs. What is the end goal? Merely to promote Open Source culture and proper software development within our college.\nHow far down the road are we? Not that far, the egg has just been laid. As of the time of writing this post, we have just started out. For the effort to work out, we welcome interested folks over :)\nWhat can I do? Just what you\u0026rsquo;ve been doing so far, but with more people!\nIf you have any interesting projects that you have already been working on, let us know and we\u0026rsquo;ll put them on the cbrtl page for more people to see. Note that there is some criteria that projects must qualify, some of these are intentionally vague. But as long as you\u0026rsquo;re doing more than following a course or tutorial, it\u0026rsquo;s likely to be accepted :)\nVolunteering to cbrtl We are looking for volunteers for some roles. Note however, that there is no strict mandate for responsibilities. As long as you\u0026rsquo;re capable of adding something of value, no matter how small, shoot us a message! We\u0026rsquo;re looking for some help with:\nCode reviewers: If you have experience contributing to FOSS or writing code for user/developer facing products, perhaps you can volunteer and help us out here :)\nEditors: We plan on writing frequent blog posts. But both the technical content and the english material can use a second pair of eyes to help catch mistakes or inconsistent writing. If you have done some technical writing before, you can volunteer for reviewing the content in blog posts!\nTechnical Writers: If you have experience writing code but are usually on a tight schedule, you may be able to join us and share your knowledge. We want to mandate a high quality in our posts, so any tutorial/how-to guide that has been done a million times before is generally discouraged. We want to avoid redundant topics like \u0026ldquo;How to build a todo app with React\u0026rdquo; and promote posts and dev-logs / journals that are fun to read and explore.\nFrontend devs: Currently, the cbrtl website is bland and not-so-catchy. While minimalism is the core idea, we can definitely use some front-end developers to help keep the UI fresh, responsive and modern.\nModerators: To help keep the community together on discord and github.\nNOTE We do not expect any amount of time commitment from volunteers, as long as you can make small contributions, we appreciate it. Volunteering is not druge work, and active frequent contributions are appreciated, but not required.\nThe kind of software we want to write We firmly believe in re-inventing the wheel. Writing software close to the metal helps us closely understand the behind-the-scenes of software that most take for granted. While any creative project is welcome, here are some ideas that adhere to the spirit:\nCompilers Virtual Machines and Interpreters Game Engines Operating Systems Search Engines Database engines Voxel renderers TCP/IP stack VCS All of these are but regular software that we tend to take for granted, that can be (and have been) written from scratch. We encourage all kinds of creative projects no matter how basic. But you can expect the above group projects to come to life as the community grows.\nShowcasing your project This post has more on that. If you want to showcase your project on our github org, then reach out to us on discord or the mailing list.\n","permalink":"https://cbrtl.github.io/posts/what-and-why/","summary":"What is cbrtl? cbrtl is an attempt at creating a tight knit group of programmers to showcase and collaborate on projects and\nWhat do we do here? Create fun projects. Either in groups or in isolation. Organize community and online showcases for group and individual projects. Contribute to Open Source projects both in cbrtl and in other communities. Conduct code reviews and JAMs. Share resources to learn. Create and maintain dev-journals and blogs.","title":"Hello world!"},{"content":"So you read up on open source, read up on cbrtl and want to start hacking. There are some preliminaries that you should take care of first. These are listed in order:\nCreate a GitHub account. Set up git on your local computer. If you\u0026rsquo;re on windows, download GitBash and follow the install instructions. Get a personal test repo set up and try out commands like push, commit, pull etc. Join the GitHub organization by adding yourself to the members list (More on that below). Join the Discord server. Alright, you\u0026rsquo;re set to start out. At this point, I would recommend getting familiar with GitHub, reading up some articles and blogs. I highly recommend Atlassian\u0026rsquo;s git tutorials and documentation.\nMaking your first Pull Request (NOTE: If you have experience using git and don\u0026rsquo;t want to waste time, just ping the @cbrtl moderator role on discord and we\u0026rsquo;ll add you).\nIf you had to follow through the above, then it\u0026rsquo;s likely that you\u0026rsquo;ve never made a PR before. To get your feet wet, make your first PR on our member\u0026rsquo;s list repo. Once you do that, you\u0026rsquo;ll be recognized as a member of cbrtl on GitHub. You will find a step by step guide on how to do that on the repository\u0026rsquo;s README.\nDone? Great! ðŸŽ‰\nNow you\u0026rsquo;re going to have to wait for a moderator to merge your PR. That should be done by the time you\u0026rsquo;re done reading this article ;)\nGetting the most out of it The way you grow and shape your journey into Open Source is dictated by your level of engagement with people, and participation in projects, discussions and the like. Now then, how do you define \u0026ldquo;engagement\u0026rdquo; and \u0026ldquo;participation\u0026rdquo;? It can mean different things for different people, but the recurring ideas are the same.\nWays to participate Contributing to the blog. Part-taking in open source projects being built in the community. Coming up with your own project ideas, and getting people to contribute. Showcasing projects you have made on cbrtl blog and GitHub organization. Contributing to larger open source projects outside cbrtl. Asking questions, getting to know people better. Volunteering on development and content moderation. Details here Starting your own project. It would be great to have more interesting projects available for people to work on. Look at the project showcase post for relevant information.\n","permalink":"https://cbrtl.github.io/posts/getting-started/","summary":"So you read up on open source, read up on cbrtl and want to start hacking. There are some preliminaries that you should take care of first. These are listed in order:\nCreate a GitHub account. Set up git on your local computer. If you\u0026rsquo;re on windows, download GitBash and follow the install instructions. Get a personal test repo set up and try out commands like push, commit, pull etc. Join the GitHub organization by adding yourself to the members list (More on that below).","title":"Getting started with cbrtl and FOSS"},{"content":"This post is taken from fuzzymf\u0026rsquo;s post\nI stumbled upon KoalasToTheMax while reading a blog post about the most exciting web pages built for fun, and I was blown away. Srijan explained how it works, and we were inspired to create something similar.\nBut first, let\u0026rsquo;s get into the basics of the data structures used inÂ ourÂ project.\nQuadtree A quadtree is a tree-based data structure where each node has exactly four child nodes. Our quadtree represents a partition of space in two dimensions by dividing the region into four equal quadrants. Each quadrant is then subdivided into four equal quadrants, and so on. Each node in the tree has exactly four children or no children at all, which makes it a leaf node. The height of a quadtree depends on the amount of data beingÂ decomposed.\nThe root node is the image. Each node is the average value of its children\u0026rsquo;s pixel values. The tree is recursively subdivided until each leaf node is a single pixel. The tree is then traversed to compress the image. To decompress the image, the tree is traversedÂ again.\nMember Functions Our quadtree has the following member functions:\ncompressImageData : It takes the image data and the compression factor as the input and returns the quadtree. createQTreeOfHeight : It takes the height of the tree and the bounding box as the input and returns the quadtree. populate : It populates the quadtree with the pixel values. getRGBValuesFromCoordinates : It takes the quadtree and the coordinates as the input and returns the pixel value at the given coordinates. Node The QTNODE class represents a node in the quadtree. It has the following properties:\nx : x-coordinate y : y-coordinate w : width of the bounding box. h : height of the bounding box. children : array of four children. rgb : pixel value of the node. Functions:\ndraw : draws the node. Takes the canvas context as the input and returns nothing. insert: inserts a node into the quadtree. Takes the quadtree and the node as the input and returns the quadtree. drawAtHeight: draws the nodes at a given height. Takes the canvas context, the height of the tree, and the current height as the input and returns nothing. draw: draws the nodes. Takes the canvas context and the height of the tree as the input and returns nothing. reveal: reveals the nodes. Takes the canvas context and the height of the tree as the input and returns nothing. computeAverageColor: computes the average color of the node. Takes the quadtree and the image data as the input and returns the pixel value. Demonstration Hover over any part of the canvas to recursively divide it into four quadrants. The slider controls the depth of the tree. The slider is set to 0 by default, which means the entire image is compressed into a single pixel. The slider when set to 100 means the image is not compressed at all. The slider can be set to any value between 0 and 100. Setting up the Canvas To start with, we need two canvases - one for you to hover over and the other for you to control the depth of the tree using a slider and render the nodes evenly. Initially, we had multiple ways of taking an image as the input form, such as uploading an image, using query parameters, etc. But for this demonstration, we\u0026rsquo;ll keep it simple and use a static image.\nHere\u0026rsquo;s some JavaScript code that will load the imageÂ intoÂ aÂ canvas:\nconst image = new Image(); img.src = \u0026#34;/assets/images/qtree/cryptopunk.jpeg\u0026#34;; img.onload = () =\u0026gt; { initSliderCanvas(img); initMouseCanvas(img); }; I\u0026rsquo;ll go ahead and explain the working of the mouse hover canvas and you can explore the slider canvas. The code is available on GitHub, and you can play around with it later if you are interested.\nimport { compressImageData } from \u0026#34;./qdtree.js\u0026#34;; function initMouseCanvas(img){ const canvas = document.getElementById(\u0026#34;canvas-2\u0026#34;); const ctx = canvas.getContext(\u0026#34;2d\u0026#34;); const imageData = readImageDataUsingCanvas(canvas, ctx, image); const qTree = compressImageData(imageData, 1); qTree.draw(ctx); ... } Image Data Compression Now, let\u0026rsquo;s get to the fun part - compressing images. We import the compressImageData function from the qdtree.js file. This function takes the image data and the compression factor as the input and returnsÂ theÂ quadtree. The height of the tree is calculated by taking the log of the number of pixels in the image and dividing it by the log of 4 ( number of children of a node ). The log of 4 is 2, and the log of the number of pixels is the height of the tree. The height of the tree is then rounded down to the nearest integer. The tree is then created using the createQTreeOfHeight function that takes the height of the tree and the bounding box as the input and returns the quadtree.\nqdtree.js\nexport function compressImageData(imageData, factor) { const { width, height } = imageData; const newWidth = Math.ceil(width / factor); const newHeight = Math.ceil(height / factor); const qTreeHeight = Math.floor(Math.log(newWidth * newHeight) / Math.log(4)); const qTree = createQTreeOfHeight(qTreeHeight, { x: 0, y: 0, w: width, h: height, }); populate(qTree, imageData); return qTree; } The createQTreeOfHeight function takes in the height of the tree and the bounding box as the input and returns the quadtree.\nBounding Box The bounding box is the area that the node represents. The bounding box is initially the entire image. The bounding box is then divided into four equal quadrants, and the process is repeated until the height of the tree is 0. The populate function takes the quadtree and the image data as the input and populates the tree with the average pixel values of the children\u0026rsquo;s pixel values.\nfunction createQTreeOfHeight(height, aabb) { function recursiveCreate(node, height) { if (height === 0) return; const { x, y, w, h } = node.aabb; const halfW = w / 2; const halfH = h / 2; //top left node.tl = new QTNode({ x, y, w: halfW, h: halfH, }); //top right node.tr = new QTNode({ x: x + halfW, y, w: halfW, h: halfH, }); //bottom left node.bl = new QTNode({ x, y: y + halfH, w: halfW, h: halfH, }); //bottom right node.br = new QTNode({ x: x + halfW, y: y + halfH, w: halfW, h: halfH, }); recursiveCreate(node.tl, height - 1); recursiveCreate(node.tr, height - 1); recursiveCreate(node.bl, height - 1); recursiveCreate(node.br, height - 1); } } Image data to Quadtree Alright, let\u0026rsquo;s talk about the reveal function, which is like a magician revealing the hidden nodes under the mouse. And then there\u0026rsquo;s the draw function, which is like an artist sketching the nodes on the canvas. The update function is like your mom constantly cleaning up after you every 30 milliseconds. It clears the canvas and redraws the nodes on the canvas, all to make sure it looks neat and tidy.\nfunction initMouseCanvas(img){ ... const mousePos = { x: 0, y: 0 }; let lastUpdateTime = -Infinity; const frameTime = 30; function update() { const currentTime = Date.now(); const diff = currentTime - lastUpdateTime; if (diff \u0026lt; frameTime) return; lastUpdateTime = currentTime; ctx.clearRect(0, 0, canvas.width, canvas.height); qTree.reveal(mousePos.x, mousePos.y); qTree.draw(ctx); } canvas.addEventListener(\u0026#34;mousemove\u0026#34;, (e) =\u0026gt; { const rect = canvas.getBoundingClientRect(); const x = e.clientX - rect.left; const y = e.clientY - rect.top; mousePos.x = x; mousePos.y = y; update(); }); } Conclusion So, what\u0026rsquo;s the point of all this? Well, we can use a quadtree to compress and decompress images when the mouse hovers over a specific area of the canvas. It\u0026rsquo;s like a secret code that unlocks a hidden image! The next task would be adding a subtle animation to reveal the image when the mouse hovers over the canvas. If you want to contribute, you can fork this repo and create a pull request.\nIf you want to explore more, check out the slider and the entire source code on GitHub. And don\u0026rsquo;t hesitate to ask us any questions or give suggestions. We\u0026rsquo;re always happy toÂ chatÂ onÂ GitHub!\nRef: Wikipedia\n","permalink":"https://cbrtl.github.io/posts/qtree/","summary":"This post is taken from fuzzymf\u0026rsquo;s post\nI stumbled upon KoalasToTheMax while reading a blog post about the most exciting web pages built for fun, and I was blown away. Srijan explained how it works, and we were inspired to create something similar.\nBut first, let\u0026rsquo;s get into the basics of the data structures used inÂ ourÂ project.\nQuadtree A quadtree is a tree-based data structure where each node has exactly four child nodes.","title":"QTree"},{"content":" NOTE: This blog post is taken from injuly\u0026rsquo;s website\nTry drawing something on the first canvas, and watch two sets of mechanical alien arms retrace your sketch:\nOnce you\u0026rsquo;re done with this introduction to Fourier analysis, you\u0026rsquo;ll be capable of making this (and a lot more) yourself.\nThe satisfying animation is made possible by the subject of this post - an infinite sum called the Fourier series. The formula is short, and with some effort, you can memorize it. However, I implore you to understand where the series comes from, and build deeper intuition for it.\nTo keep you from clicking off this page, I\u0026rsquo;ll defer the proof and origin of this equation to the second half, and thread some interactive animations through the body of this write-up.\nAdding functions Surely, you\u0026rsquo;re familiar with the addition of numbers, vectors and matrices. Adding functions is not so different. The addition of two functions \\(f\\) and \\(g\\) at input \\(x\\) is simply \\(f(x) + g(x)\\).\nPut more formally - \\((f + g)(x) = f(x) + g(x)\\).\nLet\u0026rsquo;s visualize this by taking an example. Assume f is \\(2sin(x)\\) and g is \\(cos(2x)\\).\nTheir sum then, can be given by a function - \\(h(x) = 2sin(x) + cos(2x)\\).\nThe graph below plots \\(f\\) and \\(g\\) in shades of gray, and their sum, \\(h\\), in red.\nNote how in some places, the values of \\(f\\) and \\(g\\) are both positive, and their sum is therefore a larger positive number, while in other places, \\(f\\) and \\(g\\) have opposite signs and their values cancel out to a smaller number.\nThrough the lens of physics, you could look at the functions as two electromagnetic waves, or just visible light rays oscillating in the domain of time. When two such waves overlap with each other in space, they\u0026rsquo;re said to be in superposition. The superposition of two waves results in the sum of both waves.\nWhen two points in a wave supplement each other to result in a higher amplitude (the y-value), their interaction is termed \u0026ldquo;constructive interference\u0026rdquo;. When they cancel each other out, it\u0026rsquo;s called \u0026ldquo;destructive interference\u0026rdquo;.\nGo through the last two paragraphs again, and try to digest this idea. Now, imagine if we had to work our way backwards. Say we are given a list containing the (x, y) coordinates of all points along the curve of \\(h\\), where \\(x\\) is time and \\(y\\) is the corresponding output of \\(h\\) at that point in time. We have to come up with two simpler periodic functions that sum up to \\(h\\).\nThis is exactly what the Fourier series does.\nThere are several ways to interpret interference in the real world. If \\(f\\) and \\(g\\) were sound waves, their constructive interference would make loud noise, while the destructive interference would produce a quieter sound. If they were light waves instead, their constructive interference would reveal bright spots on a reflective surface, and destructive would look like dim patches.\nApplications of the Fourier series spill into almost every domain - signal processing, image compression, shape recognition, analog transmission, noise cancellation, studying thermodynamic systems and fitting equations to datasets.\nFrom this wide array of applications, We show our interest in the science of tracing ugly sketches.\nDecomposing periodic functions. Imagine you had a machine that could scan any food item and display its recipe. Fourier series does exactly that, except for mathematical functions.\nThe Fourier series of any periodic function \\(f(x)\\) with a frequency of \\(\\omega_0\\) is described as:\n$$ f(x) = a_0/2 + \\sum_{n=1}^{\\infty}b_n sin(n\\omega_0x) + \\sum_{n=1}^{\\infty}a_n cos(n\\omega_0x) $$ Meaning that for every periodic function \\(f\\), there exists a set of coefficients \\(a\\) and \\(b\\), such that \\(f(x)\\) can be expressed as an infinite sum of sine and cosine terms of increasing frequencies where the \\(nth\\) sine term has a coefficient of \\(b_n\\) and the \\(nth\\) cosine term has a coefficient of \\(a_n\\). The values of these coefficients are given by the following formulae:\n$$ a_n = \\int_0^T{f(x)cos(nw_0x)} $$\n$$ b_n = \\int_0^T{f(x)sin(nw_0x)} $$\nThe interval of integration, \\(T\\), is the fundamental period of the function. \\(T\\) and \\(\\omega_0\\) are related by this equation:\n$$ \\omega_0 = 2\\pi/T $$\nIf that was too wordy and made little sense to you, that\u0026rsquo;s okay. We\u0026rsquo;ll prove this equation later in the post. Until then, an example will help understand this better.\nConsider the square wave - a periodic signal that alternates between 1 and -1 depending on its input. Formally, it is described like so:\n$$ f(t) = 4 \\lfloor{t}\\rfloor - 2\\lfloor2t\\rfloor + 1 $$\nHere\u0026rsquo;s how it looks when graphed out:\nIf we use the first few terms from \\(f\\)\u0026rsquo;s Fourier series, we can closely approximate the behavior of this function. In the following graph, the gray curve represents the the square wave and the red curve represents our approximation of it. You can play with the slider to alter the number of terms we take from the series and see how that changes our approximation.\nClearly, our approximation improves as we take more terms from the series. The Fourier series can be proven to converge. This means that if we take an infinite number of terms from the series, we can get the exact value of \\(f(x)\\) for any \\(x\\).\nOf course, it is not possible to add up infinite terms in computers. Instead, we decide upon a fixed number of terms that approximate our function well enough for most practical purposes.\nWhenever I say \u0026ldquo;Fourier series of a function\u0026rdquo;, I mean a series of simple periodic functions that can be added at any given input to approximate the output of the original function at the same input. For the remainder of this post our goal with Fourier series is to approximate periodic functions with sums of simpler sine/cosine functions.\nDrawing with the Fourier series If you wish to understand how the Fourier series works before seeing it in action, you can skip this section and read ahead to the proof, then come back here.\nSo, How do we go from decomposing time domain functions to recreating sketches?\nImagine you\u0026rsquo;re drawing a sketch on a square sheet of paper. You are to draw your sketch, start to finish, without lifting the nib of your pen from the paper\u0026rsquo;s surface. In other words, your sketch must be continuous with no \u0026ldquo;breaks\u0026rdquo; in between.\nAssume also that the bottom-left corner of the sheet is its origin. Once you start drawing, I can delineate the position of the pen\u0026rsquo;s tip using a pair of coordinates \\((x, y)\\) at any given point in time.\nMuch like a cartesian plane, the \\(x\\) coordinate represents the horizontal distance from the origin, and \\(y\\) the vertical. Both the x and y coordinates change as the pen moves on the sheet\u0026rsquo;s surface. Meaning, the position of the x-coordinate of your pen\u0026rsquo;s tip can be written as a function of time. Say you draw this figure:\nIf we plot the x and y-coordinates independently as functions of time, they\u0026rsquo;ll form curves that look like this:\nThe blue curve represents the values of x-coordinates of your sketch. The vertical axis represents the x-value, and the horizontal axis represents time. Similarly, the red curve plots the y-coordinates.\nBoth these curves can be viewed as functions of time. The blue curve represents a function \\(x(t)\\) that returns the x-position of the pen\u0026rsquo;s tip at time \\(t\\), Similarly, the red curve is a function \\(y(t)\\) which the same for its y-position. For each of these functions, we can find a Fourier series that approximates it.\nLet \\(f_x(t)\\) and \\(f_y(t)\\) be the Fourier approximations for \\(x(t)\\) and \\(y(t)\\) respectively. Then recreating the sketch requires computing the values returned by f_t and y_t over a range of values of t. then pairing them into (x, y) coordinates and connecting the coordinates with lines. Here is some pseudo-typescript code that mimics this logic:\n// The \u0026#34;dt\u0026#34; is our time step. // In the real world, a line is an infinitely long series of points. // In computers, we take a \u0026#34;snapshot\u0026#34; of the pen\u0026#39;s position // every dt seconds and join these positions with straight lines to // trace the curve. Smaller values of dt require more computation, // and yield better results. const dt = 0.01; const f_x = fourier_series(x); // type of x is (t: number) =\u0026gt; number const f_y = fourier_series(y); // type of y is (t: number) =\u0026gt; number let prev_point = [f_x(0), f_y(0)]; for (let t = 0.01; t \u0026lt; 1; t += dt) { const current_point = [f_x(t), f_y(t)]; draw_line(prev_point, current_point); prev_point = current_point; } The approximation generated by this method is shown below. Just as before, you can play with the slider to adjust the number of terms used in approximation of the sketch.\nKeep in mind that f_x and f_y are really just sums of simpler sine/cosine functions, calculated using Fourier\u0026rsquo;s formulae.\nYou may be wondering - the functions \\(x(t)\\) and \\(y(t)\\) aren\u0026rsquo;t periodic, how come we can still decompose them into sine/cosine sums? One trick is to set the period to infinity, and compute the series at this limit.\nIn my code, I just set the period to 1 time unit, and assume that the pen just retraces the drawing again and again. Meaning that \\(x(t + 1) = x(0)\\). This makes the math a lot easier, and certainly doesn\u0026rsquo;t make a difference in the outcome.\nTo be more clear, when the sketch starts, the time is assumed to be 0, and when it ends, the time is assumed to be 1 second. Every time point in between is scaled accordingly. This is not necessary of course, you could set the time period to however long it took to draw the first sketch, if that makes things simpler for you.\nEpicycles The final caveat are the epicycles. It is easy to just plot the values returned by \\(f_x\\) and \\(f_y\\) on the cartesian plane. But how do we animate this using revolving circles?\nIf you\u0026rsquo;ve followed the contents of this article so far, you already know how to recreate sketches. To animate them, you need to understand The polar coordinate system.\nYou can read the wikipedia article, or this article to build some intuition for conversion between cartesian and polar coordinates.\nIn the polar coordinate system, a periodic function with period \\(T\\) is a vector that rotates around the origin, and completes one full rotation around itself every \\(T\\) time units. Look at the graph of \\(sin(t)\\) in Polar form, for example:\nNote how the y-coordinates of the vector\u0026rsquo;s tip traces out a regular sine wave. You can just as easily plot any periodic function in the polar coordinate system. To add two periodic functions together, take one rotating vector and center it on the tip of the another rotating vector. The end result is shown below. The following animation shows 3 rotating vectors added together, each representing a periodic function:\nTo convert a sketch to an epicycle animation then, all we need is to convert a term in the Fourier series from cartesian to polar coordinates. Once we have that, we can add up the terms like in the animation above, and figure out the x and y-coordinates using two sets of epicycles, each representing the Fourier approximation for \\(x(t)\\) or \\(y(t)\\).\nTo do this conversion, we can use the polar form of the Fourier series. Precisely, these are the steps you need to follow:\nRepresent the sketch as a list of points drawn over a period of time. Convert the list of points into a two separate lists, one containing the x-coordinates of the sketch, and other the y. Convert each list into a function (I use this simple helper). Now, you have the \\(x(t)\\) and \\(y(t)\\). For each function, find its Fourier series coefficients. Here is how I do it. For each function, convert the Fourier series coefficients into a set of polar functions. Using a time step of dt, find the final x and y positions of our approximation, and draw them on a canvas. If you do everything correctly, you should get something like this:\nThere is a more novel approach to retracing sketches that involves using only one set of epicycles. It uses the complex Fourier Series, and is also fewer lines of code. When you\u0026rsquo;re new to this concept however, it may throw you off balance, especially if you\u0026rsquo;re not familiar with imaginary numbers and the Argand plane.\nProof When I set out to find an \u0026ldquo;intuitive\u0026rdquo; proof for the Fourier series, all I saw were proofs that begin by stating the equation, and then proving it by finding the coefficients \\(a_n\\) and \\(b_n\\) using integrals. But where did the equation come from?\nDid God whisper it to Joseph Fourier in his dreams?\nDid he just happen to run into it by chance?\nSurprisingly, the answer is \u0026ldquo;yes\u0026rdquo;. Of course, he had an unparalleled instinct for math that he whetted with years of practice and research. There has to be a certain train of thought that he boarded to arrive at this revelation, that any periodic signal can be represented as a sum of simpler harmonics. But that line of thinking was never publicized, and as you\u0026rsquo;ll see in the next section, there have been people who\u0026rsquo;ve thought of this even before Fourier himself did!\nThe important part is that Fourier asked a question that was mocked as stupid and bizarre until he presented a proof. And that proof does in fact begin by stating the following hypothesis:\n$$ f_o(t) = \\sum_{n = 0}^\\infty{b_nsin(n\\omega_0t)} $$\nHere, \\(f_o\\) is an odd function with a fundamental period of \\(w_0\\). If we can derive a value for \\(b_n\\) from this equation, we can be convinced that any odd function can be represented as a sum of sinusoids.\nNow, consider an even function \\(f_e\\) with a period of \\(w_0\\):\n$$ f_e(t) = \\sum_{n=0}^{\\infty}a_n cos(n w_0 t) $$\nIf we can derive a value for \\(a_n\\) from this equation, we can be convinced that any even function can be represented as a sum of co-sinusoids.\nWhen you combine these two equations with the idea that any periodic function can be represented as a sum of odd and an even function, you get:\n$$ f_o(t) + f_e(t) = \\sum_{n = 0}^\\infty{b_nsin(n\\omega_0t)} + \\sum_{n=0}^{\\infty}a_n cos(n w_0 t) $$\nWe can turn the order of this proof, and first say that given any function \\(f(t)\\), we can find its odd and even parts using the odd-even decomposition rule. Then, we can represent the odd part as a sum of sinusoids, and the even part as a sum of co-sinusoids.\nNow, all that\u0026rsquo;s left is to derive the values for \\(a_n\\) and \\(b_n\\) using the two equations stated above. This is where I save myself the trouble of writing more LaTeX, and defer you to this excellent proof by professors from Swarthmore college. I know I said I\u0026rsquo;d walk you through the proof, but I can\u0026rsquo;t do a better job of it than the electronics professors at Swarthmore did already. I\u0026rsquo;d hate to repeat their work and not give credit. If you follow the page I linked, you\u0026rsquo;ll realize that the proof only uses basic calculus and trigonometric identities taught in high school.\nOrigins You\u0026rsquo;ll be surprised to learn that the idea behind the series predates Fourier himself.\n2 centuries before Fourier, Carl Friedrich Gauss created several algorithms to aid his study of astronomy. He was one of the many applied mathematicians who wanted to predict the position of Ceres in the night sky. One of the algorithms he discovered in this quest, was the Fast Fourier Transform - a function that is very closely related with the Fourier Series. However, he never published his work because he believed his method to be an unimportant detail in his achievement of estimating Ceres\u0026rsquo; position.\nIn the 1700s, Euler had found applications for decomposing periodic functions with Fourier Series.\nHalf a century before Fourier, Bernoulli was studying the motion of a string. He proposed the idea that periodic functions can be represented as sums of harmonics. Nobody at the time believed this to be a general method, and his ideas were left unexplored.\nThings changed in 1807, when a French math wizard named Joseph Fourier found himself studying the heat equation in a metal plate. In his search for a solution, he sought to ask a seemingly absurd question:\nCan we represent any periodic function as a sum of simple sine and cosine functions?\nPrecisely, he sought to represent any periodic function \\(f(x)\\) with a frequency of \\(\\omega_0\\) , in the following form:\n$$ f(x) = (a_0 + a_1 cos(\\omega_0 t) + a_2 cos(2\\omega_0 t) + ... + a_n cos(n\\omega_0t)) + (b_1 sin(\\omega_0 t) + b_1 sin(2\\omega_0 t) + ... + b_n sin(n\\omega_0t) $$ Revered mathematicians of the time, including Langrange and Laplace, rejected this idea as informal and hand-wavy. The panel evaluating his findings said:\n\u0026ldquo;The manner in which the author arrives at these equations is not exempt of difficulties and\u0026hellip;his analysis to integrate them still leaves something to be desired on the score of generality and even rigour.\u0026rdquo; Perhaps this was because of a lack of reasoning as to why one should even begin to think of periodic functions this way.\nIt\u0026rsquo;s not unheard of mathematical ideas to sprout into existence out of seemingly ridiculous places. Ramanujan attributed some of his major findings to God, and dipped at the age of 32.\nAfter the Fourier Series was accepted by the scientific populace, it spawned a new field of research, called Fourier analysis. Developments in this field found everyday use in almost every science.\nApplications By this point, you know enough about Fourier analysis to delve deeper into it yourself. It would be a shame to blunt the edge of theory by not applying it in practice.\nHere a few things you could do:\nImplement noise reduction in sounds. Sharpen images with denoising. Write a JPEG encoder/decoder. Fit an elephant Write basic shape recognizers. Resources and further reading 3b1b - But what is a Fourier series?. Swarthmore college - The fourier series. Jez Swanson - An interactive introduction to the fourier transform. Tony Rosler - myFourierEpicycles ","permalink":"https://cbrtl.github.io/posts/fourier/","summary":"NOTE: This blog post is taken from injuly\u0026rsquo;s website\nTry drawing something on the first canvas, and watch two sets of mechanical alien arms retrace your sketch:\nOnce you\u0026rsquo;re done with this introduction to Fourier analysis, you\u0026rsquo;ll be capable of making this (and a lot more) yourself.\nThe satisfying animation is made possible by the subject of this post - an infinite sum called the Fourier series. The formula is short, and with some effort, you can memorize it.","title":"Fourier Series"},{"content":"Sometime during my 2nd year in college, I\u0026rsquo;d made a hobby programming language that turned out quite well. It\u0026rsquo;s named \u0026ldquo;Vyse\u0026rdquo;, after Guinsoo\u0026rsquo;s Scythe of Vyse from DotA.\nVyse is a dynamically typed, interpreted and fast scriptling language inspired by Lua for rapid prototyping of applications like video games. Programmers familiar with Lua/Javascript can pick up the language within an hour. Vyse also comes with a C++ API for frictionless embedding in projects.\nFeatures include:\nModules, both native and user-level An embedding API Closures, higher order functions to facilitate FP. Prototypical inheritance, inspired from JS and Lua. Since the language already has detailed (but remarkably outdated) documentation on its website, I won\u0026rsquo;t bother rewriting any of that here.\nInstead, here is the simple number-guessing program:\nconst math = import(\u0026#34;math\u0026#34;) fn play() { const num = math.randint(0, 100) let guess = input(\u0026#34;guess: \u0026#34;):to_num() let n_attempts = 1 while guess != num { if guess \u0026lt; num { print(\u0026#34;Too low! Try higher.\u0026#34;) } else { print(\u0026#34;Too high! Try lower.\u0026#34;) } n_attempts += 1 guess = input(\u0026#34;guess: \u0026#34;):to_num() } print(\u0026#34;Well done! number of attempts: \u0026#34;, n_attempts) } play() Of course, it\u0026rsquo;s possible to do more than just write simple terminal programs. For instance, I\u0026rsquo;m currently working on a 2D game engine that will allow users to write games with the language. This project hasn\u0026rsquo;t seen any major progress in the past year owing to my busy (read: poorly managed) schedule, however, I\u0026rsquo;m looking to resume this project in the coming quarter.\nCurrently, there are no official releases for Vyse. This is majorly due to me not being in possession of a windows (yuck) device ATM. There are some bugs that I\u0026rsquo;ve yet to prune out before I can make a stable v0.1 release for all platforms.\nThe one benefit of having no users, is a leisurely development pace.\n","permalink":"https://cbrtl.github.io/posts/vyse/","summary":"Sometime during my 2nd year in college, I\u0026rsquo;d made a hobby programming language that turned out quite well. It\u0026rsquo;s named \u0026ldquo;Vyse\u0026rdquo;, after Guinsoo\u0026rsquo;s Scythe of Vyse from DotA.\nVyse is a dynamically typed, interpreted and fast scriptling language inspired by Lua for rapid prototyping of applications like video games. Programmers familiar with Lua/Javascript can pick up the language within an hour. Vyse also comes with a C++ API for frictionless embedding in projects.","title":"Project: Vyse"},{"content":"Why is it called \u0026lsquo;cbrtl\u0026rsquo;? Because every other GitHub org name was taken.\nIt comes from the C stdlib function cbrtl.\nThere is a some trivia to the oddly text-to-speechified name.\nIn older versions of ANSI C, only the first 6 characters of an identifier were considered when compiling source code. So most standard library functions in C have odd names like strstr, strtod, alloca and so on\u0026hellip;\nWhy at all? Some of my acquaintances from other colleges have clubs, groups and spaces dedicated to open source and software development. Couple of days ago, I came across IIT Roorkee\u0026rsquo;s SDSLabs and PES Uni\u0026rsquo;s PES Open Source. After looking into it a bit more, turns out most colleges these days have their own groups for related stuff.\nWe thought it would be fun to have a similar group of like minded developers from our college.\nIs it too ambitious? We won\u0026rsquo;t know until we don\u0026rsquo;t try.\nWhat is it that cbrtl aims to do exactly? Good question. We don\u0026rsquo;t have a concrete answer. That said, I\u0026rsquo;ll throw in most of what we\u0026rsquo;ve gathered from our goal so far, and you decide if you like the sound of it.\nContributing to Open Source. Talks and meetups. Showcasing projects from individuals and teams. Code reviews and educational blogs (hopefully ones that haven\u0026rsquo;t been done to death before\u0026hellip;). What platforms are you present on? For now, our presence is limited to Discord and the GitHub organization. Mostly because these are very solid platforms and we are tight on the number of people moderating.\nWhat skills do I need? Not much.\nThe ability to code. The willingness to learn. Basic knowledge of Git and GitHub. Even 1 and 3 are optional.\nWhere do I join? As mentioned earlier, you can join the Discord and the GitHub organization. More info on Getting started with cbrtl and Open Source.\nIs there anything I can do to help? You can volunteer to help us keep the community thriving. We are looking for volunteers who can help with:\nFront end development: To touch up the current blog site. Moderation: To manage the discord server and the GitHub org. Code reviews: To mandate some code quality for those who demand it. Technical Writers: To aid in writing blog posts. Editors: A second pair of eyes helps catch common mistakes in writing :) Is this an official college club? No. This is an entirely independent student initiative that is looking for active participation. A decentralized group of like-minded programmers.\nWill there be events with cash prizes? No. And we want to be upfront about it. We want to keep this community closed to people who code because they like creating. Of course, that is not to say we discredit any other motivation you may have.\nAs such, we won\u0026rsquo;t conduct any competitions with cash prizes for the foreseeable future. Other clubs (which are official) in our college do a great (citation needed*) job at that regardless.\nWhat kinds of events can I expect? Other than project showcases and on-demand code review sessions, we are open to other ideas.\nNot as much of an \u0026rsquo;event\u0026rsquo; but you can expect group projects that will (hopefully) be active throughout.\nI have some other questions, where can I ask? You\u0026rsquo;re more than welcome on the mailing list, or in the discord server.\n","permalink":"https://cbrtl.github.io/posts/faq/","summary":"Why is it called \u0026lsquo;cbrtl\u0026rsquo;? Because every other GitHub org name was taken.\nIt comes from the C stdlib function cbrtl.\nThere is a some trivia to the oddly text-to-speechified name.\nIn older versions of ANSI C, only the first 6 characters of an identifier were considered when compiling source code. So most standard library functions in C have odd names like strstr, strtod, alloca and so on\u0026hellip;\nWhy at all?","title":"FAQ"},{"content":"This page intends to establish some minor ordinances surrounding project ideas and showcases. cbrtl was created with the intent of promoting the spirit of Open Source. Often times, some of the most interesting Open Source projects live in lesser known corners of GitHub, collecting dust on a lonesome profile with 3-5 followers and an occasionally active commit graph.\nCbrtl is an attempt at stringing together these unrelated projects into a web of resources and dev-logs that might be of use to on-lookers.\nTo avoid noisy applications and tutorial cut-pastes, we enforce a standard and a few (lax) rules.\nWhat constitutes showcase-worthy software? Anything that serves a clear purpose. A project can be showcased if it satisfies the following criteria:\nHas a proper github README.md Is not a tutorial follow-through. So anything along these lines is generally discouraged: \u0026ldquo;todo app in react\u0026rdquo; \u0026ldquo;planner app in vue\u0026rdquo; \u0026ldquo;terminal tic-tac-toe with C\u0026rdquo; and so on\u0026hellip; Is being actively worked on by it\u0026rsquo;s developer(s). It is OK even if it\u0026rsquo;s in infancy when the project is first showcased. Is open to contribution from people. Is not a lazy fork (Forks that are some-what different from the parent repos are absolutely okay). Examples Here\u0026rsquo;s a few examples to show what we mean by \u0026ldquo;showcase-able projects\u0026rdquo;. Note that not all of them are from the members of cbrtl, since we\u0026rsquo;re just starting out.\nlevk: A 3D Game engine written in C++ and Vulkan. Author: karnage SocioMark: A social media platform with plagiarism and attack-proof authenticity checks for user uploaded content. Author: Aitik Gupta Vyse: A fast, dynamically typed and interpreted programming language. Author: srijan_ (cough self-plug) locc: A C++ utility to count lines of code in a project. Author: karnage Lume: A Lua library for gamedev. Author: rxi Getting your project showcased. You have made something, or at least the skeleton of something that will go on to become a full fledged project. How do you put your code and product on cbrtl?\nReach out to us either on the mailing list, or on the discord server. Have the following ready: A GitHub repo with a well set-up README A (short) write-up describing the scope, aim, tech-stack and architecture of your project. Shoot any moderator with the aforementioned and we\u0026rsquo;ll give you: A GitHub repo symlink (symlink?) on the cbrtl org page. A community showcase. A blog post referencing the content from your write-up, describing the project. Encourage other members to collaborate and contribute. A good place to start getting involved can be our Discord server.\nHave an idea? Want a team? It is not so uncommon for programmers to get an idea but not have enough time commitment (or knowledge) to drive the idea to fruition. If that\u0026rsquo;s how things end up for you, then we might be able to help with pointing you in the right direction.\nWe may be able to help turn your solo idea into a collaborative work environment. You can choose to have the repo be on the org, or on your GitHub profile.\n","permalink":"https://cbrtl.github.io/posts/project-showcase/","summary":"This page intends to establish some minor ordinances surrounding project ideas and showcases. cbrtl was created with the intent of promoting the spirit of Open Source. Often times, some of the most interesting Open Source projects live in lesser known corners of GitHub, collecting dust on a lonesome profile with 3-5 followers and an occasionally active commit graph.\nCbrtl is an attempt at stringing together these unrelated projects into a web of resources and dev-logs that might be of use to on-lookers.","title":"Showcasing your project on cbrtl"}]