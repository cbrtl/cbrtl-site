<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Conway's Game of Life | cbrtl</title>
<meta name=keywords content><meta name=description content="Understanding computational models and implementing Conway's Game of Life using simple rules that mimic real-life population dynamics."><meta name=author content="anubhab"><link rel=canonical href=https://cbrtl.github.io/posts/game-of-life/><link crossorigin=anonymous href=/assets/css/stylesheet.min.1510f69ebe140cb95a870f85fae2b17967bf7423cc1723929921c18b0dae961f.css integrity="sha256-FRD2nr4UDLlahw+F+uKxeWe/dCPMFyOSmSHBiw2ulh8=" rel="preload stylesheet" as=style><link rel=icon href=https://cbrtl.github.io/favicon.ico><link rel=apple-touch-icon href=https://cbrtl.github.io/apple-touch-icon.png><link rel=alternate hreflang=en href=https://cbrtl.github.io/posts/game-of-life/><meta name=twitter:card content="summary"><meta name=twitter:title content="Conway's Game of Life | cbrtl"><meta name=twitter:description content="Understanding computational models and implementing Conway's Game of Life using simple rules that mimic real-life population dynamics."><meta property="og:title" content="Conway's Game of Life | cbrtl"><meta property="og:description" content="Understanding computational models and implementing Conway's Game of Life using simple rules that mimic real-life population dynamics."><meta property="og:type" content="article"><meta property="og:url" content="https://cbrtl.github.io/posts/game-of-life/"><meta property="og:image" content="https://cbrtl.github.io/papermod-cover.png"><meta property="og:image" content="https://cbrtl.github.io/assets/icon.ico"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-11-21T00:00:00+00:00"><meta property="article:modified_time" content="2024-11-21T00:00:00+00:00"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://cbrtl.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Conway's Game of Life","item":"https://cbrtl.github.io/posts/game-of-life/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Conway's Game of Life | cbrtl","name":"Conway\u0027s Game of Life","description":"Understanding computational models and implementing Conway's Game of Life using simple rules that mimic real-life population dynamics.","keywords":[],"wordCount":"2623","inLanguage":"en","datePublished":"2024-11-21T00:00:00Z","dateModified":"2024-11-21T00:00:00Z","author":{"@type":"Person","name":"anubhab"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://cbrtl.github.io/posts/game-of-life/"},"publisher":{"@type":"Organization","name":"cbrtl","logo":{"@type":"ImageObject","url":"https://cbrtl.github.io/favicon.ico"}}}</script><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary-bg:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list-page{background:var(--theme)}.list-page:not(.dark)::-webkit-scrollbar-track{background:0 0}.list-page:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript></head><body class="type-posts kind-page layout-" id=" top"><script data-no-instant>function switchTheme(e){switch(e){case"light":document.body.classList.remove("dark");break;case"dark":document.body.classList.add("dark");break;default:window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")}}function isDarkTheme(){return document.body.className.includes("dark")}function getPrefTheme(){return localStorage.getItem("pref-theme")}function setPrefTheme(e){switchTheme(e),localStorage.setItem("pref-theme",e)}const toggleThemeCallbacks={};toggleThemeCallbacks.main=e=>{setPrefTheme(e?"light":"dark")},window.addEventListener("toggle-theme",function(){const e=isDarkTheme();for(const t in toggleThemeCallbacks)toggleThemeCallbacks[t](e)});function toggleThemeListener(){window.dispatchEvent(new CustomEvent("toggle-theme"))}</script><script>(function(){const t="auto",e=getPrefTheme(),n=e||t;switchTheme(n)})()</script><header class=header><nav class=nav><div class=logo><a href=https://cbrtl.github.io/ accesskey=h title="cbrtl (Alt + H)">cbrtl</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://cbrtl.github.io/archives/ title=Archive>Archive</a></li><li><a href=https://cbrtl.github.io/search/ title="Search (Alt + /)" data-no-instant accesskey=/>Search</a></li><li><a href=https://cbrtl.github.io/tags/ title=Tags>Tags</a></li></ul></nav></header><main class="main post"><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://cbrtl.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://cbrtl.github.io/posts/>Posts</a></div><h1 class=post-title>Conway's Game of Life</h1><div class=post-description>Understanding computational models and implementing Conway's Game of Life using simple rules that mimic real-life population dynamics.</div><div class=post-meta><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>November 21, 2024</span></span><span class=meta-item>
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>13 min</span></span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#abstract-machines-and-the-computational-universe aria-label="Abstract machines and the computational universe">Abstract machines and the computational universe</a></li><li><a href=#conways-game-of-life aria-label="Conway&amp;rsquo;s Game of Life">Conway&rsquo;s Game of Life</a></li><li><a href=#the-game-of-life-in-action aria-label="The Game of Life in Action">The Game of Life in Action</a></li><li><a href=#a-turing-complete-machine aria-label="A Turing Complete Machine">A Turing Complete Machine</a><ul><li><a href=#building-a-cpu-in-the-game-of-life aria-label="Building A CPU in the Game of Life">Building A CPU in the Game of Life</a><ul><ul><li><a href=#arithmetic-logic-unit aria-label="Arithmetic Logic Unit">Arithmetic Logic Unit</a></li></ul></ul></li><li><a href=#memory-unit aria-label="Memory Unit">Memory Unit</a><ul><ul><ul><li><a href=#blinker aria-label=Blinker>Blinker</a></li></ul></ul></ul></li><li><a href=#control-unit aria-label="Control Unit">Control Unit</a><ul><li><a href=#glider-gun aria-label="Glider gun">Glider gun</a></li></ul></li><li><a href=#a-fully-functional-computer aria-label="A Fully Functional Computer">A Fully Functional Computer</a></li></ul></li><li><a href=#next aria-label=Next>Next</a></li></ul></div></details></div><div class=post-content><script type=module src=/js/game-of-life/main.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})'></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><h1 id=abstract-machines-and-the-computational-universe>Abstract machines and the computational universe<a hidden class=anchor aria-hidden=true href=#abstract-machines-and-the-computational-universe>¶</a></h1><p>Automata theory is a branch of theoretical computer science that deals with abstract machines and the computational problems that can be solved using these machines. Automata are mathematical models of a machine that can perform certain computations. Essentialy, these are <strong>fundamental units of computation</strong> that can process input and produce output based on a set of rules. They are used to model and analyze computational systems, study the limits of computation, and explore the properties of formal languages(sets of strings of symbols that can be recognized by automata).</p><p>For example, this automaton can be thought of as a machine that processes input strings of 0s and 1s and produces an output based on a set of rules, such as:</p><p>$f: {0, 1}^* \rightarrow {0, 1}^*$</p><p>where $f$ is a function that takes an input string of $0$s and $1$s and produces an output string of $0$s and $1$s, based on the following rules:</p><ul><li>If the input string contains an odd number of 1s, the output string should be 1.</li><li>If the input string contains an even number of 1s, the output string should be 0.</li></ul><p>This automaton can be represented as a state machine, with states representing the number of 1s seen so far and transitions based on the input symbols. The machine starts in an initial state and transitions between states based on the input symbols, eventually reaching a final state that determines the output.</p><p>In simpler terms, think of it this way: an automaton is the smallest part of a machine that can operate independently and perform a specific task. Breaking this unit further would lead us nowhere, as it is the smallest indivisible part of a machine that can perform a computation. Like, a gearbox in a car is an automaton that performs the task of changing gears, and it can&rsquo;t be broken down further into smaller parts that perform any meaningful task.</p><h1 id=conways-game-of-life>Conway&rsquo;s Game of Life<a hidden class=anchor aria-hidden=true href=#conways-game-of-life>¶</a></h1><p>Building on automata theory, cellular automata are computational systems used to model complex systems and nonlinear dynamics. They are made up of simple, identical units called cells that evolve in parallel at discrete time steps. The state of each cell is determined by the states of its neighbouring cells, and the cells update their states based on a set of rules. Cellular automata have been used to study a wide range of phenomena, including biological systems, physical processes, and social dynamics.</p><p>A fascinating aspect of cellular automata is their ability to exhibit complex and unpredictable behaviour from simple rules that mimic real-life population dynamics. Conway&rsquo;s Game of Life is a simple cellular automaton devised by the British mathematician John Horton Conway in 1970. It is a zero-player game, meaning that its evolution is determined by its initial state, requiring no further input. One interacts with the Game of Life by creating an initial configuration and observing how it evolves. Specifically, the game explores how simple rules governing individual cells can lead to emergent complexity and patterns over time, including stable structures, oscillating patterns, and even patterns that exhibit motion.</p><p>A few rules govern the evolution of the game are as follows:</p><ol><li><p>Any live cell with fewer than two live neighbours dies, as if by underpopulation.<div class=container style=display:flex;align-items:center;justify-content:center;text-align:center><canvas id=lessthantwo style="border:1px solid #000">
</canvas>
<span style=padding:10px;color:#000!important>-->
</span><canvas id=lessthantwodead style="border:1px solid #000"></canvas></div></p></li><li><p>Any live cell with two or three live neighbours lives on to the next generation.<div class=container style=display:flex;align-items:center;justify-content:center;text-align:center><canvas id=twoorthree style="border:1px solid #000">
</canvas>
<span style=padding:10px;color:#000!important>-->
</span><canvas id=twoorthreelive style="border:1px solid #000"></canvas></div></p></li><li><p>Any live cell with more than three live neighbours dies, as if by overpopulation.<div class=container style=display:flex;align-items:center;justify-content:center;text-align:center><canvas id=morethanthree style="border:1px solid #000">
</canvas>
<span style=padding:10px;color:#000!important>-->
</span><canvas id=morethanthreedead style="border:1px solid #000"></canvas></div></p></li><li><p>Any dead cell with exactly three live neighbours becomes a live cell, as if by reproduction.<div class=container style=display:flex;align-items:center;justify-content:center;text-align:center><canvas id=three style="border:1px solid #000">
</canvas>
<span style=padding:10px;color:#000!important>-->
</span><canvas id=threelive style="border:1px solid #000"></canvas></div><br></p></li></ol><p>The game is played on a two-dimensional grid of cells, each of which can be in one of two states: alive or dead. The game proceeds in discrete steps, with each step representing a generation of cells. At each step, the game applies the rules to each cell in the grid simultaneously, updating the grid to reflect the new state of each cell based on its current state and the states of its neighbours.</p><h1 id=the-game-of-life-in-action>The Game of Life in Action<a hidden class=anchor aria-hidden=true href=#the-game-of-life-in-action>¶</a></h1><p><div style=text-align:start;width:100%><button id=reset>Reset</button></div><br><div class=container style=display:flex;align-items:center;justify-content:center;text-align:center><canvas id=game-of-life style="border:1px solid #000"></canvas></div><div class=container style=display:flex;flex-direction:column;align-items:center;justify-content:center;margin-top:20px><input type=range id=grid-slider name=speed min=5 max=15 value=10>
<label for=speed style=margin-top:10px>Grid</label>
<span id=time style=margin-top:10px></span>
<span id=population style=margin-top:10px></span></div><div class=container style=display:flex;align-items:center;justify-content:start;margin-top:20px><label for=speed style=margin-right:10px>Speed </label><input type=range id=speed-slider name=speed min=1 max=10 value=1></div><br><div><button id=start-stop style=margin-right:10px>Start</button></div><br><strong>Generations</strong>: <span id=generation>0</span></p><p>To start, design your initial configuration by clicking on the cells to toggle their state. Once you&rsquo;re ready, click the &ldquo;Start/Stop&rdquo; button to watch the game evolve. You can pause the game at any time by clicking the &ldquo;Stop&rdquo; button, and clear the grid by clicking the &ldquo;Clear&rdquo; button.</p><p>The speed of the game can be adjusted by changing the <code>speed</code> slider. The game will evolve at a faster pace as the slider is moved to the right. The <code>grid</code> slider can be used to adjust the size of the grid, allowing for larger or smaller configurations.</p><h1 id=a-turing-complete-machine>A Turing Complete Machine<a hidden class=anchor aria-hidden=true href=#a-turing-complete-machine>¶</a></h1><p>This might seem cool; just a game, right? It&rsquo;s more interesting than that. To explain why, I would have to make your brain hurt a little bit more.</p><p>Automata like these can be classified into two main categories: finite automata( finite states, finite memory) and infinite automata(infinite states, infinite memory). For example, a finite automaton can be used to recognize whether a given input string is a valid email address or a phone number(A <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions>regular expression</a>). Infinite automata are more complex and powerful. For example, an infinite automaton can be used to recognize whether a given input string is a valid programming language statement or a mathematical expression. (Compilers and interpreters). Game of Life is a prime example of an infinite automaton, as it can simulate complex systems and exhibit infinite states from a fixed configuration.</p><p>Finite automata can be further classified into:</p><ol><li>Deterministic Finite Automata (DFA): A determined outcome for a given input.</li><li>Non-Deterministic Finite Automata (NFA): Various outcomes for a given input.</li></ol><p>However, both DFA and NFA:</p><ul><li>Operate on a finite amount of memory (the states).</li><li>Can only make decisions based on the current state and the immediate input.</li><li>Cannot handle languages that require unbounded memory, like those involving nested structures or long-term dependencies.</li></ul><p>To solve these issues, a Pushdown Automaton (PDA) was introduced. A PDA is an automaton with a <strong>stack</strong> that can store an unbounded amount of memory. It can push and pop symbols onto the stack, allowing it to handle <strong>context-free languages</strong>( languages that can be described by context-free grammar; languages powerful enough to describe many programming language constructs, such as nested structures (e.g., balanced parentheses, if-else blocks)) that require more complex memory access. Simply put, a PDA can recognize languages that a DFA or NFA cannot, making it a more powerful model of computation.</p><p>Bear with me, this useless information will make sense in a bit; I promise. The concepts of FSMs lay the groundwork for understanding why this cellular automaton is such a fascinating piece of work by this brilliant British mathematician.</p><p>However, a PDA still has limitations:</p><ul><li>The stack provides memory, but it&rsquo;s limited in structure (LIFO- Last in First Out).</li><li>It can&rsquo;t handle languages requiring more general or unbounded memory access.</li></ul><p>This led to the development of the Turing Machine, a theoretical model of computation that can simulate any algorithm or computation that can be performed by a digital computer. A Turing machine consists of an infinite tape divided into cells, a read/write head that can move left or right along the tape and a finite set of states. The machine can read the symbol on the current cell, write a new symbol, move the tape left or right, and change its state based on a set of rules.</p><p>Turing Machine is the pinnacle of computation, as it laid the foundation for modern computers and computational theory. It can, in theory, solve any computational problem that can be solved by a digital computer, making it a universal model of computation. Whatever we see today, from the smallest microcontroller to the most powerful supercomputers, satelite systems, and AI, all are based on the principles of the Turing Machine.</p><p>The Game of Life has been shown to be Turing complete, meaning it can simulate any computation that a Turing machine can perform, given the right initial conditions. Certain configurations in the Game of Life can be used to simulate logic gates, memory, and other components of a computer, demonstrating its computational universality and performing universal computation, making it a fascinating area of study for computer scientists and mathematicians alike. It has been studied extensively by computer scientists, mathematicians, and physicists, and has been used to explore a wide range of topics, including complexity theory, artificial life, and emergent behaviour.</p><h2 id=building-a-cpu-in-the-game-of-life>Building A CPU in the Game of Life<a hidden class=anchor aria-hidden=true href=#building-a-cpu-in-the-game-of-life>¶</a></h2><p>Having come this far, let&rsquo;s attempt to build a CPU in the Game of Life. A CPU essentially is built up of three main components:</p><ol><li>ALU (Arithmetic Logic Unit): Performs arithmetic and logical operations on data.</li><li>Memory: Stores data and instructions that are currently being executed by the CPU.</li><li>Control Unit: Manages the CPU&rsquo;s operations by directing data between the ALU, memory, and I/O devices.</li></ol><h4 id=arithmetic-logic-unit>Arithmetic Logic Unit<a hidden class=anchor aria-hidden=true href=#arithmetic-logic-unit>¶</a></h4><p>The <strong>ALU</strong> is responsible for performing arithmetic and logical operations on data. It consists of a number of logic gates, adders, and other components that work together to perform operations such as addition, subtraction, AND, OR, and NOT.<div class=container style=display:flex;align-items:center;justify-content:center;text-align:center><div style=margin:10px><canvas id=alu-addition style="border:1px solid #000"></canvas><div>Adder Circuit</div></div><div style=margin:10px><canvas id=alu-andgate style="border:1px solid #000"></canvas><div>AND Gate</div></div></div></p><p>In addition, you can set up a glider collision that represents the addition of two binary values. Each glider can be thought of as representing a binary input (either 0 or 1). The gliders in this pattern are designed to approach each other from opposite directions. When two gliders collide, they interact to produce an output, which can be interpreted as the sum of the two inputs. This collision represents the addition of two binary values, with the output glider moving in a different direction depending on the inputs.</p><ul><li>If only one glider is present (input 1 + 0 or 0 + 1), it moves through without a collision, representing a result of 1.</li><li>If two gliders collide (input 1 + 1), they create a predictable pattern that can represent the sum of these inputs, often leaving behind a specific &ldquo;output&rdquo; glider that can represent the result.</li></ul><p>Similarly, An AND gate can be created by positioning still-life patterns (static configurations that do not change) to manipulate gliders. If both inputs are &ldquo;1&rdquo; (represented by gliders arriving simultenously), they will interact to produce an output.</p><ul><li>If both gliders arrive at the interaction point simultaneously, they will interact in a way that produces a specific pattern, representing the output 1 for an AND operation.</li><li>If only one glider arrives, it will pass through or interact with other cells without producing the 1 pattern, representing an output of 0.</li></ul><h2 id=memory-unit>Memory Unit<a hidden class=anchor aria-hidden=true href=#memory-unit>¶</a></h2><p><strong>Memory Unit</strong> stores data and instructions that are currently being executed by the CPU. It consists of registers, cache, and main memory. It is responsible for storing and retrieving data from memory locations.</p><h5 id=blinker>Blinker<a hidden class=anchor aria-hidden=true href=#blinker>¶</a></h5><div class=container style=display:flex;align-items:center;justify-content:center;text-align:center><div style=margin:10px><canvas id=memory style="border:1px solid #000"></canvas><div>Memory Cell(1 block)</div></div></div><p>This configuration is a 3x3 blinker, which oscillates between two shapes in two generations. Its oscillation does not spread or decay, so it remains contained and stable in its oscillating state.</p><p>Memory can be represented by stable patterns that remain constant unless disturbed by an external glider or oscillator. Stable patterns like blocks act as &ldquo;bits&rdquo; that can be toggled on or off by gliders, representing data storage. These two states can represent binary values (0 and 1) in a very simplistic way, with each state encoding one bit of information depending on its phase. This stability in position and periodic change makes it suitable for acting as a memory cell, as it reliably returns to a known state every two generations.</p><p>Similarly, an external pattern could be designed to change or &ldquo;write&rdquo; to the memory cell, altering its oscillation phase to represent a different binary state.</p><h2 id=control-unit>Control Unit<a hidden class=anchor aria-hidden=true href=#control-unit>¶</a></h2><p>The control unit manages the CPU&rsquo;s operations by directing data between the ALU, memory, and I/O devices. It fetches and decodes instructions, then signals the ALU and memory to execute.<div class=container style=display:flex;align-items:center;justify-content:center;text-align:center><div style=margin:10px><canvas id=control style="border:1px solid #000"></canvas><div>Control Unit</div></div></div></p><p>This pattern is designed to function as a control unit by leveraging the behavior of known oscillators and spaceships in the Game of Life to produce predictable and repeatable outcomes. The pattern includes configurations that will evolve into gliders, which are small patterns that move across the grid over successive generations. Gliders can be used to transmit information or interact with other patterns in the grid.</p><h3 id=glider-gun>Glider gun<a hidden class=anchor aria-hidden=true href=#glider-gun>¶</a></h3><p>A glider gun is a configuration of cells that emits gliders at regular intervals. It can be used to create a clock signal that controls the timing of operations in the CPU.</p><div class=container style=display:flex;align-items:center;justify-content:center;text-align:center><div style=margin:10px><canvas id=glider style="border:.2px solid #000"></canvas><div>Glider Gun</div></div></div><p>A single block here can represent &lsquo;1&rsquo; and an empty cell can represent &lsquo;0&rsquo;. The glider gun emits gliders at regular intervals, which can be used to synchronize the operations of the CPU. These inputs can work with adders, logic gates, and memory cells to perform ALU operations, store data, and control the flow of information within the CPU.</p><h2 id=a-fully-functional-computer>A Fully Functional Computer<a hidden class=anchor aria-hidden=true href=#a-fully-functional-computer>¶</a></h2><p>To build a fully functional computer, you would need to design and implement a wide range of components, including registers, multiplexers, and arithmetic logic units, and connect them to form a complete system. Some of the components you would need to build include:</p><p>ALU components:</p><ul><li>Adders (Half and Full- they can be used to add binary numbers) <a href=/posts/game-of-life/#arithmetic-logic-unit>⏎</a></li><li>Logic Gates (AND, OR, NOT, XOR, etc.- they perform logical operations on binary inputs) <a href=/posts/game-of-life/#arithmetic-logic-unit>⏎</a></li><li>Multiplexers( MUX- they select one of many inputs and route it to the output, used to handle multiple data inputs and control signals)</li><li>Registers( they store data temporarily during processing and can be used to store intermediate results)</li></ul><p>Memory components:</p><ul><li>Flip-Flops (they store a single bit of data using feedback) <a href=/posts/game-of-life/#memory-unit>⏎</a></li><li>RAM (Random Access Memory- they store data that can be read and written to used for storing data and instructions specific to the program)</li><li>ROM (Read-Only Memory- they store data that can only be read from- used for storing fixed data and instructions that do not change)</li></ul><p>Control Unit components:</p><ul><li>Finite State Machines (FSM- they have a finite number of states and transition between states based on inputs) <a href=/posts/game-of-life/#control-unit>⏎</a></li><li>Clock Signals (they provide a timing mechanism for the CPU, controlling the rate at which operations are performed- using glider guns) <a href=/posts/game-of-life/#control-unit>⏎</a></li><li>Instruction Decoders (they interpret instructions and direct the flow of data within the CPU)</li></ul><h1 id=next>Next<a hidden class=anchor aria-hidden=true href=#next>¶</a></h1><p>While it is theoretically possible to build a computer within the Game of Life, it is painstakingly complex and fun! It requires a deeper understanding of logic gates, instruction sets, implementing memory, and control units.</p><p>Building the CPU would take you to combine these components to carry out fully functional operations. It would be a fun and challenging project to undertake, requiring a deep understanding of digital logic and computer architecture. The Game of Life serves as a fascinating model of how complexity can arise from simplicity, providing insight into topics such as self-organization, emergence, and cellular automata theory.</p><p><a href=https://nicholas.carlini.com/writing/2021/unlimited-register-machine-game-of-life.html>Here&rsquo;s an actual CPU built in the Game of Life by Nicholas Carlini</a>. In this series of posts, he tries to explain how he built digital logic gates, multiplexers, and registers in the Game of Life. I would love to do this someday when NYU is not down my throat threatening to kick me out for not doing my assignments.</p><p><em>If you choose carefully enough, you can make an entire computer inside the game, powered entirely by little things running around based only on those same simple rules of what lives and what dies in the next generation. An entire computer that could, in theory, perform any calculation that your computer could. It&rsquo;s an interesting mathematical diversion depicting Turing&rsquo;s completeness, the chaos that arises from simple rules, and it just looks pretty.</em>"</p><p>- Reddit</p><p>Also, someone built a <a href="https://www.youtube.com/watch?v=xP5-iIeKXE8">Game of Life inside a computer built on top of THE GAME OF LIFE!!</a></p></div><footer class=post-footer><nav class=paginav><a class=prev href=https://cbrtl.github.io/posts/what-and-why/><span class=title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left" style="user-select:text"><line x1="19" y1="12" x2="5" y2="12" style="user-select:text"/><polyline points="12 19 5 12 12 5" style="user-select:text"/></svg>&nbsp;Prev Page</span><br><span>Hello world!</span>
</a><a class=next href=https://cbrtl.github.io/posts/fourier/><span class=title>Next Page&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right" style="user-select:text"><line x1="5" y1="12" x2="19" y2="12" style="user-select:text"/><polyline points="12 5 19 12 12 19" style="user-select:text"/></svg></span><br><span>Fourier Series</span></a></nav></footer></article><script id=giscus-script src=https://giscus.app/client.js data-repo=cbrtl/cbrtl.github.io data-repo-id="MDEwOlJlcG9zaXRvcnkzNzE0OTA2Mjc=" data-category=General data-category-id=DIC_kwDOFiR_Q84CfPV2 data-mapping=og:title data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=" light" data-lang=en data-loading=lazy crossorigin=anonymous async></script><script>document.addEventListener("DOMContentLoaded",e=>{var t=document.getElementById("giscus-script"),n=localStorage.getItem("pref-theme")==="light"?"noborder_light":"noborder_gray";t.setAttribute("data-theme",n)})</script><footer class=footer><span>&copy; 2024 <a href=https://cbrtl.github.io/>cbrtl</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>(function(){const t=""=="1";if(t)return;let e=document.getElementById("theme-toggle");e.removeEventListener("click",toggleThemeListener),e.addEventListener("click",toggleThemeListener)})()</script><script>(function(){let e=document.getElementById("menu");e&&(e.scrollLeft=localStorage.getItem("menu-scroll-position"),e.onscroll=function(){localStorage.setItem("menu-scroll-position",e.scrollLeft)});const t=""=="1",n=""=="1";if(window.matchMedia("(prefers-reduced-motion: reduce)").matches||t||n)return;document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();const t=this.getAttribute("href").substr(1),n=document.querySelector(`[id='${decodeURIComponent(t)}']`);n?(n.scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)):console.warn(`Element with id '${t}' not found.`)})})})()</script><script>document.addEventListener("DOMContentLoaded",function(){const e=document.getElementById("top-link");e?(window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(e.style.visibility="visible",e.style.opacity="1"):(e.style.visibility="hidden",e.style.opacity="0")},e.addEventListener("click",function(e){e.preventDefault(),document.documentElement.scrollIntoView({behavior:"smooth"})})):console.warn("Scroll-to-top button is missing.")})</script><script>if(window.scrollListeners)for(const e of scrollListeners)window.removeEventListener("scroll",e);window.scrollListeners=[]</script><script src=/js/medium-zoom.min.js data-no-instant></script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script>(function(){const a=""=="1";if(!a)return;if(!document.querySelector(".toc")){console.log("no toc found, ignore toc scroll");return}const r=window.scrollListeners,t=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id]"),n="active";let e=t[0];o(e).classList.add(n);const c=()=>{const s=[];for(const e of t)if(l(e)<5)s.push(e);else break;s.length>0?newActiveHeading=s[s.length-1]:newActiveHeading=t[0],e!=newActiveHeading&&(o(e).classList.remove(n),e=newActiveHeading,o(e).classList.add(n))};let s=null;const i=()=>{s!==null&&clearTimeout(s),s=setTimeout(c,50)};window.addEventListener("scroll",i,!1),r.push(i);function o(e){const t=encodeURI(e.getAttribute("id")).toLowerCase();return document.querySelector(`.toc ul li a[href="#${t}"]`)}function l(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect();return t.top}})()</script></main></body></html>